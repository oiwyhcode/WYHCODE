#include "Trace_PID.h"
uint8_t Read_GPIO(GPIO_TypeDef* port, uint16_t pin) {
    return (HAL_GPIO_ReadPin(port, pin) == GPIO_PIN_SET) ? 0 : 1;
}



uint8_t out5,out4,out3,out2,out1;

uint8_t state[5]={};

void PID_Trace_init(PID_Trace *pid,float target_val,float Kp,float Ki,float Kd)
{
	pid->target_val=target_val;
	pid->Kp = Kp;
	pid->Ki = Ki;
	pid->Kd = Kd;


}


//float Trace_error(void) {
//    out5 = Read_GPIO(GPIOE, out5_Pin);
//    out4 = Read_GPIO(GPIOE, out4_Pin);
//    out3 = Read_GPIO(GPIOE, out3_Pin);
//    out2 = Read_GPIO(GPIOE, out2_Pin);
//    out1 = Read_GPIO(GPIOE, out1_Pin);
//    float Error = (-2.0f * out5) + (-1.0f * out4) + (0.0f * out3) + (1.0f * out2) + (2.0f * out1);
//    return Error;
//
//}
float Trace_error(void) {
    // 定义静态变量存储每个引脚的历史状态和计数器
    static uint8_t history5 = 0, history4 = 0, history3 = 0, history2 = 0, history1 = 0;
    static uint8_t count5 = 0, count4 = 0, count3 = 0, count2 = 0, count1 = 0;
    const uint8_t THRESHOLD = 3;  // 需要连续检测的次数

    // 读取当前值
    uint8_t current5 = Read_GPIO(GPIOE, out5_Pin);
    uint8_t current4 = Read_GPIO(GPIOE, out4_Pin);
    uint8_t current3 = Read_GPIO(GPIOE, out3_Pin);
    uint8_t current2 = Read_GPIO(GPIOE, out2_Pin);
    uint8_t current1 = Read_GPIO(GPIOE, out1_Pin);

    // 引脚5滤波
    if (current5 == history5) {
        count5++;
        if (count5 >= THRESHOLD) {
            out5 = current5;  // 确认稳定状态
        }
    } else {
        history5 = current5;
        count5 = 1;
    }

    // 引脚4滤波
    if (current4 == history4) {
        count4++;
        if (count4 >= THRESHOLD) {
            out4 = current4;  // 确认稳定状态
        }
    } else {
        history4 = current4;
        count4 = 1;
    }

    // 引脚3滤波
    if (current3 == history3) {
        count3++;
        if (count3 >= THRESHOLD) {
            out3 = current3;  // 确认稳定状态
        }
    } else {
        history3 = current3;
        count3 = 1;
    }

    // 引脚2滤波
    if (current2 == history2) {
        count2++;
        if (count2 >= THRESHOLD) {
            out2 = current2;  // 确认稳定状态
        }
    } else {
        history2 = current2;
        count2 = 1;
    }

    // 引脚1滤波
    if (current1 == history1) {
        count1++;
        if (count1 >= THRESHOLD) {
            out1 = current1;  // 确认稳定状态
        }
    } else {
        history1 = current1;
        count1 = 1;
    }

    // 计算误差
    float Error = (-2.0f * out5) + (-1.0f * out4) + (0.0f * out3) + (1.0f * out2) + (2.0f * out1);
    return Error;
}

void PID_Trace_realize(PID_Trace *pid, float CurrentValue) {
    // 1. 计算当前误差
    pid->Error = pid->target_val - CurrentValue;

    // 2. 计算积分项 (带积分限幅，防止积分饱和)
    pid->Integral += pid->Error;
    if (pid->Integral > 500) pid->Integral = 500;
    if (pid->Integral < -500) pid->Integral = -500;

    // 3. 计算微分项
    float derivative = pid->Error - pid->LastError;

    // 4. 计算总输出
    pid->output_val = (pid->Kp * pid->Error) +
                  (pid->Ki * pid->Integral) +
                  (pid->Kd * derivative);

    // 5. 更新上次误差
    pid->LastError = pid->Error;
}

